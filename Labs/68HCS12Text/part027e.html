<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>Frequency Meter Example</title>
<link rel="shortcut icon" href="icon.ico" />
<link type="text/css" rel="stylesheet" href="main.css"  />
</head>
<body>


<table BORDER="1" WIDTH="100%">
<tr><td><a href="part027d.html">Previous Appendix</a></td>
<td><a href="part027f.html">Next Appendix</a></td>
<td><a href="index.html">Index</a></td><td><A href="search.htm" target="search">Search the Text</a></td></tr></table>
<h1>Frequency Meter Example</h1>

<p>The goal of this project is to build a frequency meter using the
   Dragon12-Plus development board. The design is based mainly on components discussed previously in this text:</p>

<div class="minor"><ul>
  <li>The Timer Module Pulse Accumulator will be used to measure the frequency with a resolution of 1 Hz. This was done in the section <a href="part018d.html#Frequency Measurements">Frequency Measurements</a>, which included a
sample program. However the sample program had no means to display the frequency for the user.</li>
  <li>We will use the LCD display (16 characters by 2 lines) on the
     Dragon12-Plus board to display the results. The code to drive the display will be developed in this section. The display
routine will be interrupt driven an use the same timer interrupt used for the frequency measurement.</li>
  <li>The frequency value will need to be converted to an ASCII character string for display. The algorithm was given in<a href="part002.html#Conversion from Value to Text"> Conversion from Values to Digits</a>. This will be done in the idle
process. We have an entire second to convert to ASCII and display the value since the value is only updated once a second.</li>
  <li>We will implement <a href="part022c.html">output buffering</a> so that the ASCII conversion routine can send characters to the buffer as it generates them, and the LCD display can display them (via its
interrupt routine) as they become available and at the rate the display can handle.</li>
  <li>The entire program will be placed in EEPROM making the application stand-alone. To do this, we will follow the instructions in the previous section.</li>
</ul></div>

<p><a href="part027d.html"></a><a href="part017a.html"></a>The final program is available <a href="fmeter.asm">here</a>. The remainder of this section will cover the new parts of the design.
Refer to the sections linked above for operation of the frequency measurements,
value to digit conversion, and making the application stand-alone. The
normally idle process is used to convert the measurement to characters
and send to the LCD display output buffer. This is a low priority task
here - the only thing that is important is that it completes a conversion
every second. A flag is used (<em>doneflag)</em>so that it doesn't convert
the same measurement more than once.  The sections of this example are:</p>

<ul>
  <li><a href="#Driving the LCD Display">Driving the LCD Display</a></li>
  <li><a href="#The Buffered Interface">The Buffered Interface</a></li>
  <li><a href="#LCD Display State Machine">LCD Display State Machine</a></li>
  <li><a href="#Initialization and the Main Process">Initialization and the Main Process</a></li>
</ul>
<h2><a name="Driving the LCD Display">Driving the LCD Display</a></h2>

<p>The interface to the LCD involves 4 data lines (there are two transfers per byte of information), a strobe signal (EN), and command/data select signal (RS - high for data).</p>

<p><img src="fig27e1.jpg" width="302" height="311" align=bottom /></p>

<p>These connect to pins PK0 through PK5. While the LCD display has read-back capability, none is supported by the interface. As far as the microcontroller initialization is concerned,
all that is needed is:</p>
<pre>        movb    #$ff DDRK       ; port K = output
        clr     PORTK</pre>

<p>However the LCD display will require an initialization sequence.</p>

<p>The timing diagram for the LCD display from the Hantronix data sheet is:</p>

<p><img src="fig27e-2.gif" width="874" height="283" align=bottom /></p>

<p>All the times are sufficiently long (as far as the microcontroller is concerned)
that we don't have to worry about most of them. Basically we will drive
RS and the data pins to their correct values, then assert E. Then we de-assert
E. Enable must be high for at least 230nS. That's our only concern, so
a delay can be used to meet that requirement. Assuming the nibble (4 bit
value) to write is in accumulator A in the correct bit positions (2 through
5) and RS has been correctly set, the following subroutine will write the
data and perform the necessary pulsing of E:</p>
<pre>lcdnibble: ; nibble to send is in a
        psha                    ; save nibble value
        ldaa   PORTK            ; get LCD port value
        anda   #$03             ; need low 2 bits, so they won't change
        oraa   1,sp+            ; OR in low 4 bits 
        staa   PORTK            ; output data          
        bset   PORTK #ENABLE    ; ENABLE=high
        nop
        nop                     ; make pulse 250nsec wide
        bclr   PORTK #ENABLE    ; ENABLE=low
        rts</pre>

<p>The two <em>nop</em> instructions insure the enable pulse will be 250nS wide with a 24MHz system clock.</p>

<p><img src="fig27e-3.gif" width="402" height="683"/></p>
<p>The LCD display is initialized with the sequence of commands shown above
from the data sheet. We will actually initialize to a slightly different
configuration. Note that there are occasions where additional wait time
is necessary between commands. Normally the delay is 50 microseconds, except
for clearing the display which can take 1.5 milliseconds. In addition,
we have to wait 15 milliseconds before even starting any execution. To
provide these delays without otherwise slowing down the program we will
use a state machine driven by the 1 millisecond interrupt we use for the
frequency measurement. Lets also look at the output buffering which allows
the program to write multiple characters and proceed with other processing.</p>
<h2><a name="The Buffered Interface">The Buffered Interface</a></h2>

<p>The LCD state machine and buffered interface has the following data declarations:</p>
<pre>lcdbuf:    ds   LCDBUFLEN  ; LCD output buffer
lcdbufin:  ds   2          ; Pointer to buffer input
lcdbufout: ds   2          ; pointer to buffer output
lcdstate:  ds   2          ; LCD state machine state
lcddelay:  ds   1          ; LCD state machine delay counter</pre>

<p>The buffer pointers are initialized to the start of lcdbuf, the state is
initialized to LCDCLEARDELAY and the delay is initialized to 14. There
will be more information about the state machine later. The code to write
a character is taken directly from the buffering discussion in the text.
This routine is renamed from putchar to putlcd:</p>
<pre>putlcd: ; Write character in register A to LCD
        pshx
        tfr     d x             ; save A:B in X, X on stack
putlcd2: ldd     lcdbufin       ; calculate # characters in buffer
        subd    lcdbufout
        bpl     putlcd3
        addd    #LCDBUFLEN      ; If negative, adjust (circular arithmetic)
putlcd3: cpd     #LCDBUFLEN-1   ; Is there room?
        bne     putlcd4
        wai                     ; no room -- wait and try again 
        bra     putlcd2
putlcd4: tfr     x d            ; a has character 
        ldx     lcdbufin        ; get bufin again
        staa    1,x+            ; store character, increment buffer position
        cpx     #lcdbuf+LCDBUFLEN ; check for wrap
        bne     putlcd5         ; not needed?
        ldx     #lcdbuf         ; wrap to start
putlcd5: stx    lcdbufin        ; save new bufin value
        pulx
        rts</pre>

<p>How do we know the difference between a command byte and a data byte (which are the characters we want to write)? We will putlcd a $ff byte to indicate that the following byte is a
command byte. Without this prefix, the byte will be a data byte. This precludes the use of character $ff, but that is no problem. Now we can write a routine which writes to the first line
of the display (the source code shows routines for both the first and second lines):</p>
<pre>lcd_line1: ; write the character string at X, B characters long, to the first line
        ldaa    #$ff                    ; indicate instruction
        bsr     putlcd
        ldaa    #$80                    ; starting address for the line1
        bsr     putlcd
        pshy
        tfr     b,y
msg_out:
        ldaa    1,x+
        bsr     putlcd
        dbne    y msg_out
        puly
        rts</pre>

<p>The command $80 initiates a data write to the first line of the display. The list of commands is on the data sheet for the display:</p>

<p><img src="fig27e-4.gif" width="541" height="655" align=top /></p>

<p>To perform initialization (which must be done after interrupts are enabled so the state machine will run), we will execute the following code:</p>
<pre>lcd_ini:
        ldx     #inidsp
        ldab    #6
lcd_ini_loop:
        ldaa    #$ff            ; $ff means following byte is command
        jsr     putlcd
        ldaa    1,X+
        jsr     putlcd
        dbne    b lcd_ini_loop
        rts
inidsp: 
        fcb     $33             ; reset (4 nibble sequence)  
        fcb     $32             ; reset 
        fcb     $28             ; 4bit, 2 line, 5X7 dot
        fcb     $06             ; cursor increment, disable display shift
        fcb     $0c             ; display on, cursor off, no blinking
        fcb     $01             ; clear display memory, set cursor to home pos</pre>

<p>We must take care of all delays in the state machine. </p>
<h2><a name="LCD Display State Machine">LCD Display State Machine</a></h2>

<p>The state machine has 4 states, LCDIDLE, LCDCLEARDELAY, LCDRESETDELAY, and LCDCMD. The state machine code executes at the end of the 1 millisecond interrupt
routine which is used for the frequency counter. We have seen that initially the state is LCDCLEARDELAY with a counter value of 14.  Here is the code for this state:</p>
<pre>lcdfin: rti

LCDCLEARDELAY: ; waiting on clear delay
        dec     lcddelay
        bne     lcdfin
        movw    #LCDIDLE lcdstate
        rti</pre>

<p>We will be in this state for 14 interrupts, and then the state will change
to LCDIDLE. 15 interrupts will occur (15 milliseconds) before actual command
processing can begin. This supplies the initial startup delay.</p>

<p>The LCDIDLE state is the main state of the machine. This is the state that checks for a character in the buffer. If there is no character, it is finished, and will check again in the next
millisecond interrupt. Otherwise it will start processing the character. Here is the start of the state code that checks the buffer. This is basically the code used in the previous buffering
example:</p>
<pre>LCDIDLE: ; Wait for next character
        ldx     lcdbufout
        cpx     lcdbufin
        beq     lcdfin
        ldaa    1,x+ 
        cpx     #lcdbuf+LCDBUFLEN
        bne     lcdin2
        ldx     #lcdbuf
lcdin2: stx     lcdbufout</pre>

<p>If the byte is the command prefix, then we change to the LCDCMD state and start processing in that state right away (no reason to wait for the next interrupt), otherwise we write out
the data byte as two separate nibbles. When we are done, we return from the interrupt. Since the next interrupt is 1 millisecond away, the delay requirements between bytes are easily
met.</p>
<pre>        cmpa    #-1
        beq     iscmd
        psha                            ; save temporarily
        anda   #$f0                     ; mask out 4 low bits.           
        lsra
        lsra                            ; 4 MSB bits go to pk2-pk5                              
        bsr     lcdnibble
        pula
        lsla                            ; move low bits over.
        lsla
        bsr     lcdnibble
lcdfin: rti

iscmd:  movw    #LCDCMD lcdstate
LCDCMD: ...</pre>

<p>One would expect that the LCDCMD state would be the same as the LCDIDLE state but for clearing the REG_SEL bit. Again, we must fetch the byte from the buffer. However we
must have a 5 millisecond delay between nibbles when executing the reset command, and a 2 millisecond delay after a clear command. The other commands execute fast enough that
the delay between interrupts is sufficient. In any case, after sending out the command we want to end up back in the LCDIDLE state.</p>
<pre>LCDCMD:   ; Wait for command
        ldx     lcdbufout
        cpx     lcdbufin
        beq     lcdfin
        ldaa    1,x+ 
        cpx     #lcdbuf+LCDBUFLEN
        bne     lcdcin2
        ldx     #lcdbuf
lcdcin2: stx    lcdbufout
        psha                            ; save the command
        bclr    PORTK #REG_SEL          ; select instruction
        anda   #$f0                     ; mask out 4 low bits.           
        lsra
        lsra                            ; 4 MSB bits go to pk2-pk5                              
        bsr     lcdnibble
        pula
        cmpa    #$33                    ; Reset requires a 5msec delay
        beq     lcdreset
        psha
        lsla                            ; move low bits over.
        lsla
        bsr     lcdnibble
        bset    PORTK #REG_SEL          ; select data
        pula
        cmpa    #$03                    ; clear requires 5 msec delay
        bls     lcdclear
        movw    #LCDIDLE lcdstate
        rti</pre>

<p>When the clear command occurs, after the command is sent, the state is changed to LCDCLEARDELAY to delay before the next command.</p>
<pre>lcdclear: movw #LCDCLEARDELAY lcdstate  ; must delay before next command
        movb    #1 lcddelay             ; gives 2 msec delay (one more than value)
        rti</pre>

<p> In the case of the reset command, after the first nibble is sent we branch to lcdreset:</p>
<pre>lcdreset: movw #LCDRESETDELAY lcdstate   ; must delay before second part
        movb    #5 lcddelay             ; gives 5 msec delay
        rti</pre>

<p>This sets the state to LCDRESETDELAY and sets the lcddelay time variable for a 5 millisecond delay. The LCDRESETDELAY state is:</p>
<pre>LCDRESETDELAY: ; waiting on reset delay
        dec     lcddelay
        bne     lcdfin
        ldaa    #$0c                    ; reset lower nibble shifted left
        bsr     lcdnibble
        bset    PORTK #REG_SEL          ; select data
        movw    #LCDIDLE lcdstate
        rti</pre>

<p>Which sends out the second nibble of the command and returns to the idle
state.</p>
<h2><a name="Initialization and the Main Process">Initialization and the Main Process</a></h2>

<p>Since the application is stand-alone, the first step in initialization is setting the stack pointer and configuring the general microcontroller hardware. In this case we need to enable the PLL to run at 24 MHz rather than the 2 MHz we would otherwise get from the 4 MHz crystal. The remainder of the initialization code must combine that of the buffered interface and the frequency measurement example. The order of execution here is not important as long as the <em>cli</em> instruction is executed after all the initialization (except for the LCD
initialization routine) is complete. Look at the <a href="fmeter.asm">source code</a> for the example. Because of the large number of processor instructions necessary to initialize (33) it has been split into groups of
instructions with comments indicating what is being initialized.</p>

<p>The main process checks for a new value to display and loops, doing nothing, until there is a value. This doesn't hurt anything since all time sensitive operations are done in higher
priority interrupt routines. When a new value exists (as indicated by <em>doneflg</em> being nonzero, which is set by the interrupt routine when a new measurement is complete) the flag is
cleared and the value checked for being non-zero.</p>
<pre>back:   tst     doneflg
        beq     back
        clr     doneflg
        movw    frequency saved
        movw    frequency+2 saved+2
        ldaa    saved           ; Are all bits 0?
        oraa    saved+1
        oraa    saved+2
        oraa    saved+3
        beq     nomeasure       ; then there is no measurement</pre>

<p>In the case the frequency is zero, a special message is printed, and the main process goes back to waiting for a new measurement.</p>
<pre>nomeasure:                      ; display text that there is no signal
        ldx     #nomeas
        ldab    #10
        jsr     lcd_line1
        jmp     back
nomeas: fcc     'No Signal '</pre>

<p>Otherwise the frequency value is converted to a string. Seven digits are allowed, so that frequencies up to less than 10 MHz can be displayed. This is fine since the hardware can't
measure frequencies as high as 10 MHz. Some future microcontroller might require changing the number of digits to eight or more! Since the algorithm for converting a value to digits
requires repeated dividing by 10, we need to accommodate both a 32 bit dividend and a 32 bit quotient. This is accomplished by performing a sequence of two divisions. The code to
do this is:</p>
<pre>        ldy     #result+6       ; Convert to 7 digit frequency string     
loop:   pshy
        ldd     saved           ; divide 32 bit value at saved by 10, storing
        ldx     #10             ; quotient back in saved and keeping remainder
        idiv                    ; division of upper 16 bits, d has remainder, x has quotient
        stx     saved
        tfr     d y             ; prepare for second divide
        ldd     saved+2
        ldx     #10
        ediv                    ; quotient in y, remainder in D
        sty     saved+2
        addb    #'0             ; convert remainder to ASCII digit
        puly
        stab    1,y-            ; put digit in character array
        ldd     saved           ; see if quotient is zero -- if not, continue converting
        bne     loop
        ldd     saved+2
        bne     loop</pre>

<p>This will convert all significant digits. The remaining digits positions are filled with blank (non-displaying) characters:</p>
<pre>        cpy     #result         ; blank fill leading characters
        blo     done
again:  movb    #'  1,y-
        cpy     #result
        bhs     again</pre>

<p>Then the value is displayed by calling <em>lcd_line1</em>, and the process goes back to waiting for the next value.</p>
<pre>done:   ldx     #result         ; display frequency text
        ldab    #TEXTLEN
        jsr     lcd_line1
        jmp     back</pre>

<p>Continue with <a href="part027f.html"><em>Alarm Clock Example</em></a></p>
<p>Return to the <a href="index.html">Index</a>.</p>

</body>
</html>
