
as12, an absolute assembler for Motorola MCU's, version 1.2h

                        ; Array_Fun.asm
                        ; Author: D. Haley, Faculty, 26 Nov 2021
                        ; Modified by:          Zahi Masarwa, Ahmad Hodroj,Mohamad Rezk
                        ; Student Number(s):     040985420  , 041018443    ,040960130
                        ; Lab Section(s):       302
                        ; Course:               CST8216 Fall 2021
                        ; Date:                 11-12-2021
                        ;
                        ;
                        ; Purpose:      The purpose of this program is to gain further experience with
                        ;               the use of Arrays in 68HCS12 Assembly Language by performing
                        ;               the following Tasks:
                        ;
                        ;               a. Determine the Maximum value in the Array and store the
                        ;                  value at Max
                        ;               b. Determine the Minumum value in the Array and store the
                        ;                  value at Min
                        ;               c. Using the value stored at Max, determine how often that
                        ;                  value occurs in the Array and store that value at NumMax
                        ;               d. Using the value stored at Min, determine how often that
                        ;                  value occurs in the Array and store that value at NumMin
                        ;               e. Range tells how far apart the Max and Min numbers are in a set
                        ;                  It is the positive difference between the two values
                        ;                  Using the values in Max and Min, subtract those two
                        ;                  values a store the result at Range
                        ;               f. MidRange is the Average of the Range - e.g. Range / 2
                        ;                  Using the Values of Range and DIVISOR, calculate the
                        ;                  MidRange using idiv (mandatory) and store an 8-bit version of
                        ;                  the Answer at MidRange and an 8-bit version of the Reminder
                        ;                  at MidRange+1
                        ;               g. Display NumMax and NumMin on the two right-most HEX Displays
                        ;                  (like you did with the Counter), alternating their
                        ;                  displayed values every 250 ms. This coding is provided for you.
                        ;                  NOTE: API.s19 must be loaded in order for this feature to work.
                        ;               h. Code must run correctly for more than one program run
                        ;                  e.g. File -> Reset, the GO on Simulator must give same results
                        
                        ; --- Do Not Change Code marker ---
                        ; Library Routines used in this software
                        ;
2117                    Config_Hex_Displays    equ     $2117
211f                    Delay_Ms               equ     $211F
2139                    Hex_Display            equ     $2139
                        
                                                               ; Port P (PPT) Display Selection Values
000b                    DIGIT1_PP2                    equ     %1011   ; 2nd from Right-most display MSB
0007                    DIGIT0_PP3             equ     %0111   ; Right-most display LSB
                        
                                                               ; Delay Subroutine Values
00fa                    DVALUE                 equ     #250    ; Delay value (base 10) 0 - 255 ms
                                                               ; 125 = 1/8 second <- good for Dragon12 Board
                        
0002                    DIVISOR                 equ     $02    ; Values in supplied array will be divided by
                                                               ; this value
                        
1000                                                   org     $1000
1000                    Array
                        #include 21F_Array.txt
1000 24 40 f0 c3 f4 02  	db	$24,$40,$F0,$C3,$F4,$02,$C3,$E5
     c3 e5
1008 02 f3 65 aa 56 f3  	db	$02,$F3,$65,$AA,$56,$F3,$F3,$B0
     f3 b0
1010 f3 d6 01 03 0e 3e  	db	$F3,$D6,$01,$03,$0E,$3E,$40,$CC
     40 cc
1018 03 08 f3 f0 31 02  	db	$03,$08,$F3,$F0,$31,$02,$40,$01
     40 01
1020 01 f3 65 aa 56 f3  	db	$01,$F3,$65,$AA,$56,$F3,$F4,$B0
     f4 b0
1028 24 40 f0 c3 a0 02  	db	$24,$40,$F0,$C3,$A0,$02,$C3,$E5
     c3 e5
                        #endinclude

1030                    EndArray
                        
1030                                            org     $1030
1030                    Max                     ds      1
1031                    Min                     ds      1
                        
1040                                            org     $1040
1040                    NumMax                  ds      1
1041                    NumMin                  ds      1
                        
1050                                            org     $1050
1050                    Range                   ds      1
1051                    MidRange                ds      2
                        
2000                                            org     $2000
2000 cf 20 00                                   lds     #$2000
                        
                        ; --- End of Do Not Change Code marker ---
                        
                        ; your code goes here (as many lines at it takes)
2003 79 10 40                                   clr     NumMax    ;clear the contents in the following memory address
2006 79 10 41                                   clr     NumMin    ;clear the contents in the following memory address
2009 ce 10 01                                   ldx     #Array+1  ;Point X to Memory Address designated by the Label "Array"+1 which is 1001
200c a6 1f                                      ldaa    -1,x      ; Using constant offset ,load into accumlator a the value where x is pointing to memory address 1000 which is the first value in array
200e 7a 10 30                                   staa    Max       ;store the value into accumlator a which is $24 in Max
2011 7a 10 31                                   staa    Min       ;store the value into accumlator a which is $24 in Min
2014 a6 30              loop                    ldaa    1,x+      ;load into accumlator a the value stored where x is pointing in the array and after executing increment x
2016 b1 10 30                                   cmpa    Max       ;compare the value in accumlator a with the value stored in Max and check if it is higher than max
2019 22 0e                                      bhi     Maximum   ;if the value in accumlator a is higher than max branch to Maximum label
201b e6 00                                      ldab    0,x       ; Using constant offset ,load into accumlator b the value where x is pointing to memory address 1000 which is the first value in array
201d f1 10 31                                   cmpb    Min       ;compare the value in accumlator b with the value stored in Min and check if it is lower than max
2020 23 02                                      bls     minimum   ;if the value in accumlator b is lower than min branch to Minumum label
2022 20 08                                      bra     continue  ;branch to the label continue
2024 7b 10 31           minimum                 stab    Min       ;store the value into accumlator b  in Min
2027 20 03                                      bra     continue  ;branch to the label continue
2029 7a 10 30           Maximum                 staa    Max       ;store the value into accumlator a in Max
202c 8e 10 30           continue                cpx     #EndArray ;Check if we processed all the elements in the array
202f 26 e3                                      bne     loop      ;if not equal branch to loop to continue processing the elements in the array and checking the max and min
                                
2031 ce 10 00                                   ldx     #Array    ;Point X to Memory Address designated by the Label "Array" which is 1000
2034 a6 30              loop1                   ldaa    1,x+      ;load into accumlator a the value stored where x is pointing in the array and after executing increment x
2036 b1 10 30                                   cmpa    Max       ;compare the value in accumlator a with the value stored in Max and check if it is higher than max
2039 27 07                                      beq     countMax  ;if equal branch to the countMax label.
203b b1 10 31                                   cmpa    Min       ;compare the value in accumlator a with the value stored in Min and check if it is lower than min
203e 27 07                                      beq     countMin  ;if equal branch to countMin label to increment the minimum value counters
2040 20 08                                      bra     continue1 ;branch to the label continue1
2042 72 10 40           countMax                inc     NumMax    ;increment the NumMax counter by 1 to increase the count of max numbers
2045 20 03                                      bra     continue1 ;branch to the label continue1
2047 72 10 41           countMin                inc     NumMin    ;increment the NumMin counter by 1 to increase the count of min numbers
204a 8e 10 30           continue1               cpx     #EndArray  ;Check if we processed all the elements in the array
204d 26 e5                                      bne     loop1      ;if not equal branch to the loop1 again.
                                                ;clra               ;clear the accumlator a
204f f6 10 30                                   ldab    Max        ;load into accumlator b the value stored at Memory Address designated by the label Max
2052 f0 10 31                                   SUBb    Min        ;Subtract into accumlator b the value stored into accumlator b which is the max by min
2055 7b 10 50                                   stab    Range      ;store the value into accumlator b in Range
2058 ce 00 02                                   ldx     #DIVISOR   ;Load X with the value stored at Memory Address designated by the Label DIVISOR which is 2
205b 18 10                                      idiv               ;divide b by the value stored in x
205d b7 50                                      tfr     x,a        ;transfer the value stored in pointer X to a
205f 7c 10 51                                   std     MidRange   ;store the value into accumlator d in MidRange
                        
                        
                        ; --- Do Not Change Code marker ---
                        
                                                                        ; Output Results to Hex Displays
                        
                                                                        ; NOTE 1 : API.s19 must be loaded in order for this feature
                                                                        ; NOTE 2 : Once you STOP the execution of the code in simulator,
                                                                        ;you will be able to see the calculated values in memory
                                                                        ;at the memory locations specified in the assignment.
                        
2062 16 21 17                                   jsr     Config_HEX_Displays ; Use the Hex Displays to display the count
2065 b6 10 40           Display                 ldaa    NumMax
2068 c6 0b                                      ldab    #DIGIT1_PP2     ; select 2nd from Right Most HEX Display
206a 16 21 39                                   jsr     HEX_Display     ; Display the value
206d 86 fa                                      ldaa    #DVALUE         ; delay for DVALUE milliseconds
206f 16 21 1f                                   jsr     Delay_ms
2072 b6 10 41                                   ldaa    NumMin
2075 c6 07                                      ldab    #DIGIT0_PP3     ; select Right Most HEX Display
2077 16 21 39                                   jsr     HEX_Display     ; Display the value
207a 86 fa                                      ldaa    #DVALUE         ; delay for DVALUE milliseconds
207c 16 21 1f                                   jsr     Delay_ms
207f 20 e4                                      bra     Display
2081 3f                                         swi
                                                end
                                                                        ; --- End of Do Not Change Code marker ---
                        

Executed: Thu Dec 09 11:41:20 2021
Total cycles: 181, Total bytes: 178
Total errors: 0, Total warnings: 0
